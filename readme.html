<html>
<head>
	<title>Backbone.php</title>
	<style type="text/css">
		pre {
		font-size: 12px;
		padding: 2px 0 2px 15px;
		border: 4px solid #BBB;
		border-top: 0;
		border-bottom: 0;
		margin: 0px 0 25px;
		}
		code, pre, tt {
		font-family: Monaco, Consolas, "Lucida Console", monospace;
		font-size: 12px;
		line-height: 18px;
		font-style: normal;
		margin-left: 20px;
		}
		body {
		width: 600px;
		}
		li {
		margin-bottom: 8px;
		}
		b.header {
		font-size: 18px;
		line-height: 35px;
		}
	</style>
</head>
<body>
<h1>Backbone.php</h1>
<p>Backbone.php, like its javascript namesake, is a collection of scripts that help provide structure to a php application or php powered website. It follows the Model-View-Controller (MVC) convention by providing classes for handling routes, database backed models, and HTML views. Applications or websites built using Backbone.php can be up and running very quickly because it removes the necessity of writing much of the boilerplate code.</p>
<p>The framework is built with the following goals in mind:</p>
<ol>
	<li><strong>Lightweight:</strong> The core of Backbone.php provides just the right amount of structure and flexibility without being overly complicated.</li>
	<li><strong>Modular:</strong> Backbone.php is highly modular and provides a simple mechanism for including other framework and application specific modules.</li>
	<li><strong>Best Practices:</strong> Backbone.php is designed with software engineering best practices in mind, including MVC and Object-Oriented programming.</li>
</ol>
<p>At its most simplest form, a Backbone.php application is nothing more than a series of url routes (such as "/about/") that are mapped to either views ("views/about-page.php") or callback methods ("public function about($args)") or both. That is essentially all that you need to get a Backbone.php application up and running. However, the framework also provides a number of classes for working specifically with data backed by a MySQL database in the form of Models and Collections, with the aim of giving order and coherence to your business logic while emphasizing code reusibility.</p>
<hr/>
<h2>File Structure</h2>
<p>Backbone.php consists of the core framework code in a /backbone/ directory and five files that must be placed in your application's web root: 'htacces', 'backbone.php', 'config.php', 'boot.php', and 'index.php'.</p>
<ul>
	<li><strong>htaccess</strong> Uses Apache's mod_rewrite module to funnel all page requests to the index.php script, which allows for url fragments to be routed to mapped view code.</li>
	<li><strong>backbone.php</strong> Initializes the Backbone.php framework and sets up the request object. This file should not be modified.</li>
	<li><strong>config.php</strong> Sets up several directory constants required by Backbone.php to find the core framework, application, and view directories. By modifiying the FRAMEWORK constant you can place the core /backbone/ directory elsewhere than your web root.</li>
	<li><strong>boot.php</strong> Sets the web root relative path, loads routers, and performs other application specific bootstraping.</li>
	<li><strong>index.php</strong> Dispatches requests through routers registered by the application. Should not be modified.</li>
</ul>
<p id="links">Backbone.php core framework:</p>
<ul>
	<li><a href="#Backbone">Backbone.class</a></li>
	<li><a href="#Request">Request.class</a></li>
	<li><a href="#Router">Router.class</a></li>
</ul>
<hr/>
<h2 id="Backbone">Backbone.class</h2>
<p>The Backbone class is the heart of a Backbone.php application. It is a static class that handles routes and module loading as well as servers as a namespace for global objects and variables.</p>
<p><b class="header">$root</b><code>Backbone::$root</code></p>
<p>A public static string representing the web root relative to the domain name. If your web root is in the root of your domain name, then $root should be set to "/". If, say, your web root is in "www.example.com/app/" then $root should be set to "/app/". This is required for the Html class to properly format links.</p>
<p><b class="header">$config</b><code>Backbone::$config</code></p>
<p>A public static configuration object to hold all of your application's configuration settings. The $config variable is a DataSet object that exposes get() and set() methods that maniuplate key => value pairs. Keys can be namespaced using the "." operator. Values can be of any type. Some core Backbone.php classes (such as MySQL) may make use of the $config object (these will always be prefixed by the name of the class) so be sure that your key names are unique.</p>
<pre>
Backbone::$config.set("app.debugging", false);
Backbone::$config.set("mysql.log", true);
Backbone::$config.set("mysql.logfile", "/tmp/");

// returns false
Backbone::$config.get("app.debugging");
// returns true
Backbone::$config.get("mysql.log");
// returns "/tmp/"
Backbone::$config.get("mysql.logfile");
</pre>
<p><b class="header">initialize</b><code>Backbone::initialize()</code></p>
<p>Initializes the framework. This method is called by backbone.php and should not be called directly by the application.</p>
<p><b class="header">version</b><code>Backbone::version()</code></p>
<p>Returns the version number of the Backbone.php installation.</p>
<p><b class="header">uses</b><code>Backbone::uses($modules)</code></p>
<p>Includes a class module. Modules are referenced by their corresponding class name. For example, if you have a module named "Employee" then you must define a class named "Employee" and name the file "Employee.class.php" for backbone to find it. The parameter to uses() can be either a string or an arrray of strings to load multiple modules. For loading Backbone.php modules you simply pass in the class name - for application defined modules you prepend the classname with the path relative to the web root (or "/" if in the web root).</p>
<pre>
// Backbone.php module
Backbone::uses("Model");
// Load multiple Backbone.php modules
Backbone::uses(array("MySQL", "Model"));
// Load an application defined module 
Backbone::uses("/models/Employee"); 
</pre>
<p>Modules that have already been loaded are ignored by uses(). Backbone.class keeps a list of loaded modules that can be examined through:</p>
<pre>Backbone::$modules</pre>
<p><b class="header">loadRouter</b><code>Backbone::loadRouter($name)</code></p>
<p>Includes a router. This is equivalent of calling Backbone::uses("/router/[Router]").</p>
<p><b class="header">addRouter</b><code>Backbone::addRouter($router)</code></p>
<p>Registers a router instance with the framework. Routes are checked for matches in the order in which they are added.</p>
<pre>
Backbone::addRouter(new MyAppRouter());
</pre>
<p><b class="header">dispatch</b><code>Backbone::dispatch($request)</code></p>
<p>Dispatches the request by trying to find a matching route among the registered routers. This method is called by the framework in index.php and does not need to be called by the application.</p>
<p><a href="#links">Back to class list</a></p>
<hr/>
<h2 id="Request">Request.class</h2>
<p>The request object encapsulates the current server request and provides convenient methods for accessing the requested url as well as GET and POST variables. The request object is accessed through Backbone::$request after initialization.</p>
<p><b class="header">base</b><code>Backbone::$request->base()</code></p>
<p>Get the base url.</p>
<pre>
// the request is: http://www.example.com/path/to/here/?p=1
Backbone::$requst->base();
// call to base() returns "http://www.example.com"
</pre>
<p><b class="header">url</b><code>Backbone::$request->url()</code></p>
<p>Get the full url of the request.</p>
<pre>
// the requst is: http://www.example.com/path/to/here/?p=1
Backbone::$request->url();
// call to url() returns "http://www.example.com/path/to/here/?p=1"
</pre>
<p><b class="header">path</b><code>Backbone::$request->path()</code></p>
<p>Get the url path (portion that follows the base, minus query strings).</p>
<pre>
// the request is: http://www.example.com/path/to/here/?p=1
Backbone::$request->path();
// call to path() returns "/path/to/here/"
</pre>
<p><b class="header">here</b><code>Backbone::$request->here()</code></p>
<p>Get the current path of the request.</p>
<pre>
// the request is: http://www.example.com/path/to/here/?p=1
Backbone::$request->here();
// the call to here() returns "/path/to/here/" (the root here is "")
</pre>
<p><b class="header">queryString</b><code>Backbone::$request->queryString()</code></p>
<p>Get the query string.</p>
<pre>
// the request is: http://www.example.com/path/to/here/?p=1
Backbone::$request->queryString();
// the call to queryString() returns "?p=1"
</pre>
<p><b class="header">ipaddress</b><code>Backbone::$request->ipaddress()</code></p>
<p>Get the IP address of the request.</p>
<p><b class="header">link</b><code>Backbone::$request->link($subpath, [$print])</code></p>
<p>Builds a link from the base and the given subpath (or relative path).</p>
<pre>
Backbone::$requst->link("/about/team/");
// returns "http://www.example.com/about/team/"
</pre>
<p><b class="header">get</b><code>Backbone::$request->get([$key])</code></p>
<p>Get a specific GET parameter, or get the entire array of GET parameters if key is not supplied. This method performs an isset() check on the key so that you don't have to and returns null if the key is not valid.</p>
<p><b class="header">post</b><code>Backbone::$request->post([$key])</code></p>
<p>Get a specific POST parameter, or get the entire array of POST parameters if key is not supplied. This method performs an isset() check on the key so that you don't have to and returns null if the key is not valid.</p>
<hr/>
<h2 id="Router">Router.class</h2>
<p>Routers map url fragments (such as "/about/") to views and/or callback methods. You can explicitly map url fragments (always relative to your web root) to methods in your Router child class to perform application specific logic, or you can have Backbone.php route your url fragments to views automatically. Backbone.php will try and do the latter only if no callback mappings are defined by looking for a corresponding view file in your /views/ directory. These views must end in "-page". So, for example, if you have a view file named "about-page.php" then requests for "/about/" will map directly to that view file. Requests with sub-folders will only map to views in corresponding sub-folders in your views directory. For example, "/about/contact/" will map to "/about/contact-page.php" if it is defined.</p>
<p>Argument can be passed through the url using the special strings ":alpha", "alphanum", and ":number", depending on the type of argument to match (alphabetical, alpha-numeric, and numeric). These arguments will be passed in as arguments to your router's callback method. For example, if you have the url fragment "/employees/id/1234/" then you can define a route "/employees/id/:integer/" to capture the employee ID.</p>
<pre>
// Example router
Backbone::uses("Router");

class ExampleRouter extends Router 
{
	public function __construct()
	{
		parent::__construct();
		
		$this->add(array(
			"/employees/id/:integer/" => "employee_details",
			"/employees/" => "employees",
			"/" => "home"
		));
	}
	
	public function home()
	{
		// show home page
	}
	
	public function employees()
	{
		// show list of employees
	}
	
	public function employee_details($id)
	{
		// show an employee's detals
		// $id holds the employee ID
	}
}
</pre>
</body>